# Script to generate static world data from countries-states-cities database
param(
    [switch]$ForceUpdate
)

# Function to ensure submodules are up to date
function Update-Submodules {
    Write-Host "Checking submodules status..."
    $submoduleStatus = git submodule status
    
    if ($submoduleStatus -match "^[+-]") {
        Write-Host "Submodules need to be updated. Running git submodule update..."
        git submodule update --init --recursive
    } else {
        Write-Host "Submodules are up to date."
    }
}

# Function to sanitize names to be alphanumeric and Pascal case
function Get-SanitizedName {
    param([string]$name)
    
    # Remove any non-alphanumeric characters and split by spaces
    $words = $name -replace '[^a-zA-Z0-9\s]', '' -split '\s+'
    
    # Convert each word to Pascal case
    $pascalWords = $words | ForEach-Object {
        $word = $_.ToLower()
        if ($word.Length -gt 0) {
            $word[0].ToString().ToUpper() + $word.Substring(1)
        }
    }
    
    # Join the words together
    $sanitized = $pascalWords -join ''
    
    # Ensure it starts with a letter (C# requirement for identifiers)
    if ($sanitized -match '^[0-9]') {
        $sanitized = "Country$sanitized"
    }
    
    return $sanitized
}

# Function to generate C# code from JSON data
function Generate-WorldData {
    $jsonPath = "countries-states-cities-database/json/countries+states+cities.json"
    $outputDir = "src/ShowsOnSale.World/Data/Countries"
    $mainOutputPath = "src/ShowsOnSale.World/Data/WorldData.cs"
    
    Write-Host "Reading JSON data from $jsonPath..."
    $jsonData = Get-Content $jsonPath -Raw | ConvertFrom-Json
    
    # Create the output directory if it doesn't exist
    if (-not (Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    }
    
    # Create README.md in the Data directory
    $readmePath = "src/ShowsOnSale.World/Data/README.md"
    $readmeContent = @"
# World Data Directory

⚠️ **WARNING: DO NOT MODIFY FILES IN THIS DIRECTORY MANUALLY** ⚠️

This directory contains automatically generated world data files. These files are generated by the `scripts/generate-world.ps1` script and will be overwritten when the script is run again.

If you need to modify the world data:
1. Make changes to the source data in the `countries-states-cities-database` submodule
2. Run the `scripts/generate-world.ps1` script to regenerate the files

## Structure
- `WorldData.cs` - Main entry point containing all countries
- `Countries/` - Directory containing individual country data files
"@
    Set-Content $readmePath $readmeContent -Encoding UTF8
    
    # Write the initial C# code for the main file
    $initialCode = @"
// ⚠️ WARNING: This file is automatically generated by scripts/generate-world.ps1
// DO NOT modify this file manually as it will be overwritten when the script is run again.
// To update the data, modify the source data in countries-states-cities-database and run the script.

using System.Collections.Generic;
using ShowsOnSale.World.Models;

namespace ShowsOnSale.World.Data
{
    public static partial class WorldData
    {
        public static partial class Generated
        {
            public static List<Country> All { get; } = new()
            {
"@
    
    Set-Content $mainOutputPath $initialCode -Encoding UTF8
    
    # Process each country
    $totalCountries = $jsonData.Count
    $currentCountry = 0
    
    foreach ($country in $jsonData) {
        $currentCountry++
        $countryName = Get-SanitizedName $country.name
        $countryFilePath = Join-Path $outputDir "$countryName.cs"
        Write-Host "Processing country $currentCountry of $totalCountries : $($country.name)"
        
        # Generate country file
        $countryCode = @"
// ⚠️ WARNING: This file is automatically generated by scripts/generate-world.ps1
// DO NOT modify this file manually as it will be overwritten when the script is run again.
// To update the data, modify the source data in countries-states-cities-database and run the script.

using System.Collections.Generic;
using ShowsOnSale.World.Models;

namespace ShowsOnSale.World.Data.Countries
{
    public static class $($countryName)
    {
        public static Country Data { get; } = new()
        {
            Id = $($currentCountry),
            Name = "$($country.name -replace '"', '\"')",
            Iso3 = "$($country.iso3)",
            Iso2 = "$($country.iso2)",
            NumericCode = "$($country.numeric_code -eq $null ? "" : $country.numeric_code)",
            PhoneCode = "$($country.phonecode -eq $null ? "" : $country.phonecode)",
            Capital = "$($country.capital -eq $null ? "" : ($country.capital -replace '"', '\"'))",
            Currency = "$($country.currency -eq $null ? "" : $country.currency)",
            CurrencyName = "$($country.currency_name -eq $null ? "" : ($country.currency_name -replace '"', '\"'))",
            CurrencySymbol = "$($country.currency_symbol -eq $null ? "" : $country.currency_symbol)",
            Tld = "$($country.tld -eq $null ? "" : $country.tld)",
            Native = "$($country.native -eq $null ? "" : ($country.native -replace '"', '\"'))",
            Region = "$($country.region -eq $null ? "" : ($country.region -replace '"', '\"'))",
            RegionId = $($country.region_id -eq $null ? 0 : $country.region_id),
            Subregion = "$($country.subregion -eq $null ? "" : ($country.subregion -replace '"', '\"'))",
            SubregionId = $($country.subregion_id -eq $null ? 0 : $country.subregion_id),
            Nationality = "$($country.nationality -eq $null ? "" : ($country.nationality -replace '"', '\"'))",
            Latitude = "$($country.latitude -eq $null ? "" : $country.latitude)",
            Longitude = "$($country.longitude -eq $null ? "" : $country.longitude)",
            Emoji = "$($country.emoji -eq $null ? "" : $country.emoji)",
            EmojiU = "$($country.emojiU -eq $null ? "" : $country.emojiU)",
            Timezones = new()
            {
"@
        
        Set-Content $countryFilePath $countryCode -Encoding UTF8
        
        # Add timezones as single-line entries
        $timezoneCount = $country.timezones.Count
        $currentTimezone = 0
        $timezoneEntries = @()
        
        foreach ($timezone in $country.timezones) {
            $currentTimezone++
            $zoneName = $timezone.zoneName -eq $null ? "" : ($timezone.zoneName -replace '"', '\"')
            $gmtOffset = $timezone.gmtOffset -eq $null ? 0 : $timezone.gmtOffset
            $gmtOffsetName = $timezone.gmtOffsetName -eq $null ? "" : ($timezone.gmtOffsetName -replace '"', '\"')
            $abbreviation = $timezone.abbreviation -eq $null ? "" : $timezone.abbreviation
            $tzName = $timezone.tzName -eq $null ? "" : ($timezone.tzName -replace '"', '\"')
            
            $timezoneEntry = "                new() { ZoneName = `"$zoneName`", GmtOffset = $gmtOffset, GmtOffsetName = `"$gmtOffsetName`", Abbreviation = `"$abbreviation`", TzName = `"$tzName`" }$(if ([string]$currentTimezone -lt [string]$timezoneCount) { "," })"
            $timezoneEntries += $timezoneEntry
        }
        
        # Write all timezone entries at once
        Add-Content $countryFilePath $timezoneEntries -Encoding UTF8
        
        $translationsCode = @"
            },
            Translations = new()
            {
"@
        Add-Content $countryFilePath $translationsCode -Encoding UTF8
        
        # Add translations
        $translationCount = $country.translations.PSObject.Properties.Count
        $currentTranslation = 0
        foreach ($translation in $country.translations.PSObject.Properties) {
            $currentTranslation++
            $translationCode = @"
                { "$($translation.Name)" = "$($translation.Value -eq $null ? "" : ($translation.Value -replace '"', '\"'))" }$(if ([string]$currentTranslation -lt [string]$translationCount) { "," })
"@
            Add-Content $countryFilePath $translationCode -Encoding UTF8
        }
        
        $statesStartCode = @"
            },
            States = new()
            {
"@
        Add-Content $countryFilePath $statesStartCode -Encoding UTF8
        
        # Process states for this country
        $totalStates = $country.states.Count
        $currentState = 0
        
        foreach ($state in $country.states) {
            $currentState++
            Write-Host "  Processing state $currentState of $totalStates : $($state.name)"
            
            $stateCode = @"

                new()
                {
                    Id = $($currentState),
                    Name = "$($state.name -eq $null ? "" : ($state.name -replace '"', '\"'))",
                    StateCode = "$($state.state_code -eq $null ? "" : $state.state_code)",
                    Latitude = "$($state.latitude -eq $null ? "" : $state.latitude)",
                    Longitude = "$($state.longitude -eq $null ? "" : $state.longitude)",
                    Type = "$($state.type -eq $null ? "" : $state.type)",
                    Cities = new()
                    {
"@
            
            Add-Content $countryFilePath $stateCode -Encoding UTF8
            
            # Process cities for this state
            $totalCities = $state.cities.Count
            $currentCity = 0
            
            # Process cities in batches for better performance
            $cityBatchSize = 1000
            $cityBatches = [Math]::Ceiling($totalCities / $cityBatchSize)
            
            for ($batch = 0; $batch -lt $cityBatches; $batch++) {
                $startIndex = $batch * $cityBatchSize
                $endIndex = [Math]::Min(($batch + 1) * $cityBatchSize, $totalCities)
                
                Write-Host "    Processing cities batch $($batch + 1) of $cityBatches ($startIndex to $endIndex)"
                
                # Collect city entries for this batch
                $cityEntries = @()
                
                for ($i = $startIndex; $i -lt $endIndex; $i++) {
                    $city = $state.cities[$i]
                    $currentCity = $i + 1
                    
                    # Create single-line city entry with proper escaping
                    $cityName = $city.name -eq $null ? "" : ($city.name -replace '"', '\"')
                    $cityLatitude = $city.latitude -eq $null ? "" : $city.latitude
                    $cityLongitude = $city.longitude -eq $null ? "" : $city.longitude
                    
                    $cityEntry = "                        new() { Id = $($currentCity), Name = `"$cityName`", Latitude = `"$cityLatitude`", Longitude = `"$cityLongitude`" }$(if ($currentCity -lt $totalCities) { "," })"
                    $cityEntries += $cityEntry
                }
                
                # Write all city entries for this batch at once
                Add-Content $countryFilePath $cityEntries -Encoding UTF8
            }
            
            $stateEndCode = @"
                    }
                }$(if ([string]$currentState -lt [string]$totalStates) { "," })
"@
            
            Add-Content $countryFilePath $stateEndCode -Encoding UTF8
        }
        
        $countryEndCode = @"
            }
        };
    }
}
"@
        
        Add-Content $countryFilePath $countryEndCode -Encoding UTF8
        
        # Add reference to main file
        $mainReference = @"

            Countries.$countryName.Data$(if ([string]$currentCountry -lt [string]$totalCountries) { "," })
"@
        Add-Content $mainOutputPath $mainReference -Encoding UTF8
    }
    
    # Write the final closing brackets for main file
    $finalCode = @"
            };
        }
    }
}
"@
    
    Add-Content $mainOutputPath $finalCode -Encoding UTF8
    Write-Host "Generated C# code at $mainOutputPath and country files in $outputDir"
}

# Main script execution
try {
    # Update submodules if needed
    Update-Submodules
    
    # Generate world data
    Generate-WorldData
    
    Write-Host "World data generation completed successfully!"
} catch {
    Write-Error "An error occurred: $_"
    exit 1
}
